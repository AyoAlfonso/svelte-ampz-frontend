'use strict';

var index = require('./index-7460d1f3.js');
require('./index-1b506bf9.js');

const subscriber_queue = [];
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = index.noop) {
    let stop;
    const subscribers = [];
    function set(new_value) {
        if (index.safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (let i = 0; i < subscribers.length; i += 1) {
                    const s = subscribers[i];
                    s[1]();
                    subscriber_queue.push(s, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = index.noop) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
            stop = start(set) || index.noop;
        }
        run(value);
        return () => {
            const index = subscribers.indexOf(subscriber);
            if (index !== -1) {
                subscribers.splice(index, 1);
            }
            if (subscribers.length === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}

const CONTEXT_KEY = {};

const preload = () => ({});

/* src/components/Footer.svelte generated by Svelte v3.16.0 */

const Footer = index.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	return `<footer>
    <div class="${"footer"}">
        <div class="${"footer-content"}">
            <div class="${"col"}">
                <p class="${"title"}">Company</p>
                <p><a href="${"about-ampz"}">About Us</a></p>
                <p><a href="${"#"}">Team</a></p>
                <p><a href="${"#"}">Careers</a></p>
                <p><a href="${"#"}">Talent Portfolio</a></p>
            </div>
            <div class="${"col"}">
                <p class="${"title"}">Products</p>
                <p><a href="${"#"}">Platforms and Services</a></p>
                <p><a href="${"#"}">Programs</a></p>
                <p><a href="${"#"}">Store</a></p>
            </div>
            <div class="${"col"}">
                <p class="${"title"}">Legal</p>
                <p><a href="${"#"}">Terms and Conditions</a></p>
            </div>
            <div class="${"col"}">
                <p class="${"title"}">Contact</p>
                <p>
                    <a href="${"www.twitter.com/ampz_tv"}"><img src="${"img/twitter.png"}" alt="${""}"></a>
                    <a href="${"#"}"><img src="${"img/linkedin.png"}" alt="${""}"></a>
                    <a href="${"#"}"><img src="${"img/facebook.png"}" alt="${""}"></a>
                    <a href="${"#"}"><img src="${"img/instagram.png"}" alt="${""}"></a>
                </p>
                <p><a href="${"mailto:info@ampz.tv"}">info@ampz.tv</a></p>
                <p>© Copyright AMPZ.TV Limited 2019</p>
            </div>
        </div>
    </div>
</footer>


`;
});

/* src/routes/_layout.svelte generated by Svelte v3.16.0 */

const Layout = index.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	return `<main style="${"min-height:92.5vh"}">
  ${$$slots.default ? $$slots.default({}) : ``}
</main>

${index.validate_component(Footer, "Footer").$$render($$result, {}, {}, {})}`;
});

/* src/routes/_error.svelte generated by Svelte v3.16.0 */

const css = {
	code: ".errorCode.svelte-sjp0pw{font-size:150px;color:wheat;text-align:center;background-color:#fff}.back-home.svelte-sjp0pw{color:wheat;font-size:24px;text-decoration:none}",
	map: "{\"version\":3,\"file\":\"_error.svelte\",\"sources\":[\"_error.svelte\"],\"sourcesContent\":[\"<script>\\n  export let status;\\n  export let error;\\n\\n  const dev = \\\"production\\\" === \\\"development\\\";\\n</script>\\n\\n<svelte:head>\\n  <title>{status}</title>\\n</svelte:head>\\n<style>\\n.error404 {\\n    background: url(../img/noise.gif);\\n    background-repeat: repeat;\\n    background-attachment: fixed;\\n}\\n\\n.errorCode{\\n   font-size: 150px;\\n    color: wheat;\\n    text-align: center;\\n    background-color: #fff;\\n}\\n.erroMsg{\\n  font-size: 15px;\\n    color: #f1f0ef;\\n    text-transform: uppercase;\\n    text-align: center;\\n}\\n.back-home {\\n    color: wheat;\\n    font-size: 24px;\\n    text-decoration: none;\\n}\\n</style>\\n<main>\\n  <h1 class=\\\"errorCode\\\">{status}</h1>\\n  <div style=\\\"text-align:center;color: wheat;padding: 5%;\\\"> <a class=\\\"btn back-home\\\" href=\\\"/\\\">&lt; Go Home  </a>\\n</div>\\n  <!-- <p class=\\\"erroMsg\\\">{error.message}</p> -->\\n \\n<h2>Oops, something went wrong.</h2>\\n  {#if dev && error.stack}\\n    <pre>{error.stack}</pre>\\n  {/if}\\n\\n\\n\\n</main>\\n\"],\"names\":[],\"mappings\":\"AAiBA,wBAAU,CAAC,AACR,SAAS,CAAE,KAAK,CACf,KAAK,CAAE,KAAK,CACZ,UAAU,CAAE,MAAM,CAClB,gBAAgB,CAAE,IAAI,AAC1B,CAAC,AAOD,UAAU,cAAC,CAAC,AACR,KAAK,CAAE,KAAK,CACZ,SAAS,CAAE,IAAI,CACf,eAAe,CAAE,IAAI,AACzB,CAAC\"}"
};

const Error$1 = index.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	let { status } = $$props;
	let { error } = $$props;
	if ($$props.status === void 0 && $$bindings.status && status !== void 0) $$bindings.status(status);
	if ($$props.error === void 0 && $$bindings.error && error !== void 0) $$bindings.error(error);
	$$result.css.add(css);

	return `${($$result.head += `<title>${index.escape(status)}</title>`, "")}

<main>
  <h1 class="${"errorCode svelte-sjp0pw"}">${index.escape(status)}</h1>
  <div style="${"text-align:center;color: wheat;padding: 5%;"}"> <a class="${"btn back-home svelte-sjp0pw"}" href="${"/"}">&lt; Go Home  </a>
</div>
  
 
<h2>Oops, something went wrong.</h2>
  ${ ``}



</main>`;
});

/* src/node_modules/@sapper/internal/App.svelte generated by Svelte v3.16.0 */

const App = index.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	let { stores } = $$props;
	let { error } = $$props;
	let { status } = $$props;
	let { segments } = $$props;
	let { level0 } = $$props;
	let { level1 = null } = $$props;
	let { level2 = null } = $$props;
	index.setContext(CONTEXT_KEY, stores);
	if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0) $$bindings.stores(stores);
	if ($$props.error === void 0 && $$bindings.error && error !== void 0) $$bindings.error(error);
	if ($$props.status === void 0 && $$bindings.status && status !== void 0) $$bindings.status(status);
	if ($$props.segments === void 0 && $$bindings.segments && segments !== void 0) $$bindings.segments(segments);
	if ($$props.level0 === void 0 && $$bindings.level0 && level0 !== void 0) $$bindings.level0(level0);
	if ($$props.level1 === void 0 && $$bindings.level1 && level1 !== void 0) $$bindings.level1(level1);
	if ($$props.level2 === void 0 && $$bindings.level2 && level2 !== void 0) $$bindings.level2(level2);

	return `


${index.validate_component(Layout, "Layout").$$render($$result, Object.assign({ segment: segments[0] }, level0.props), {}, {
		default: () => `
	${error
		? `${index.validate_component(Error$1, "Error").$$render($$result, { error, status }, {}, {})}`
		: `${index.validate_component(level1.component || index.missing_component, "svelte:component").$$render($$result, Object.assign({ segment: segments[1] }, level1.props), {}, {
				default: () => `
			${level2
				? `${index.validate_component(level2.component || index.missing_component, "svelte:component").$$render($$result, Object.assign(level2.props), {}, {})}`
				: ``}
		`
			})}`}
`
	})}`;
});

// This file is generated by Sapper — do not edit it!

const ignore = [/^\/robots.txt$/];

const components = [
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-e5c7f1ba.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./#23423432opportunity-52be03d7.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:#23423432opportunity.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./#23423423products-1e5e504f.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:#23423423products.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./#34234234flipkart-00674253.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:#34234234flipkart.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-2ae52dcf.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:opportunities/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./new-68c44f48.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:opportunities/new.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./[slug]-fdc9ac27.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:opportunities/[slug].svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./#234234login-60497cc1.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:#234234login.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./about-ampz-837d3182.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:about-ampz.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-7e73c634.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:waitlist/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./product-a14c4ade.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:product.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./#43434[slug]-51c072d5.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:#43434[slug].svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-eba4812d.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:search/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-0f403e22.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:cart/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./order-success-69942a22.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:cart/order-success.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./checkout-319f018c.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:cart/checkout.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./_layout-9a05d209.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:my/_layout.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-d9de8d9f.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:my/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./password-a69fbe33.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:my/password.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./address-dd961e78.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:my/address.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./profile-0d4a0a5b.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:my/profile.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./orders-c5259538.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:my/orders.svelte__"
	}
];

const routes = (d => [
	{
		// index.svelte
		pattern: /^\/$/,
		parts: [
			{ i: 0 }
		]
	},

	{
		// #23423432opportunity.svelte
		pattern: /^\/%2323423432opportunity\/?$/,
		parts: [
			{ i: 1 }
		]
	},

	{
		// #23423423products.svelte
		pattern: /^\/%2323423423products\/?$/,
		parts: [
			{ i: 2 }
		]
	},

	{
		// #34234234flipkart.svelte
		pattern: /^\/%2334234234flipkart\/?$/,
		parts: [
			{ i: 3 }
		]
	},

	{
		// opportunities/index.svelte
		pattern: /^\/opportunities\/?$/,
		parts: [
			{ i: 4 }
		]
	},

	{
		// opportunities/new.svelte
		pattern: /^\/opportunities\/new\/?$/,
		parts: [
			null,
			{ i: 5 }
		]
	},

	{
		// opportunities/[slug].svelte
		pattern: /^\/opportunities\/([^\/]+?)\/?$/,
		parts: [
			null,
			{ i: 6, params: match => ({ slug: d(match[1]) }) }
		]
	},

	{
		// #234234login.svelte
		pattern: /^\/%23234234login\/?$/,
		parts: [
			{ i: 7 }
		]
	},

	{
		// about-ampz.svelte
		pattern: /^\/about-ampz\/?$/,
		parts: [
			{ i: 8 }
		]
	},

	{
		// waitlist/index.svelte
		pattern: /^\/waitlist\/?$/,
		parts: [
			{ i: 9 }
		]
	},

	{
		// product.svelte
		pattern: /^\/product\/?$/,
		parts: [
			{ i: 10 }
		]
	},

	{
		// #43434[slug].svelte
		pattern: /^\/%2343434([^\/]+?)\/?$/,
		parts: [
			{ i: 11, params: match => ({ slug: d(match[1]) }) }
		]
	},

	{
		// search/index.svelte
		pattern: /^\/search\/?$/,
		parts: [
			{ i: 12 }
		]
	},

	{
		// cart/index.svelte
		pattern: /^\/cart\/?$/,
		parts: [
			{ i: 13 }
		]
	},

	{
		// cart/order-success.svelte
		pattern: /^\/cart\/order-success\/?$/,
		parts: [
			null,
			{ i: 14 }
		]
	},

	{
		// cart/checkout.svelte
		pattern: /^\/cart\/checkout\/?$/,
		parts: [
			null,
			{ i: 15 }
		]
	},

	{
		// my/index.svelte
		pattern: /^\/my\/?$/,
		parts: [
			{ i: 16 },
			{ i: 17 }
		]
	},

	{
		// my/password.svelte
		pattern: /^\/my\/password\/?$/,
		parts: [
			{ i: 16 },
			{ i: 18 }
		]
	},

	{
		// my/address.svelte
		pattern: /^\/my\/address\/?$/,
		parts: [
			{ i: 16 },
			{ i: 19 }
		]
	},

	{
		// my/profile.svelte
		pattern: /^\/my\/profile\/?$/,
		parts: [
			{ i: 16 },
			{ i: 20 }
		]
	},

	{
		// my/orders.svelte
		pattern: /^\/my\/orders\/?$/,
		parts: [
			{ i: 16 },
			{ i: 21 }
		]
	}
])(decodeURIComponent);

function goto(href, opts = { replaceState: false }) {
	const target = select_target(new URL(href, document.baseURI));

	if (target) {
		_history[opts.replaceState ? 'replaceState' : 'pushState']({ id: cid }, '', href);
		return navigate(target, null).then(() => {});
	}

	location.href = href;
	return new Promise(f => {}); // never resolves
}

const initial_data = typeof __SAPPER__ !== 'undefined' && __SAPPER__;

let ready = false;
let root_component;
let current_token;
let root_preloaded;
let current_branch = [];
let current_query = '{}';

const stores = {
	page: writable({}),
	preloading: writable(null),
	session: writable(initial_data && initial_data.session)
};

let $session;
let session_dirty;

stores.session.subscribe(async value => {
	$session = value;

	if (!ready) return;
	session_dirty = true;

	const target = select_target(new URL(location.href));

	const token = current_token = {};
	const { redirect, props, branch } = await hydrate_target(target);
	if (token !== current_token) return; // a secondary navigation happened while we were loading

	await render(redirect, branch, props, target.page);
});

let prefetching


 = null;

let target;

let uid = 1;

let cid;

const _history = typeof history !== 'undefined' ? history : {
	pushState: (state, title, href) => {},
	replaceState: (state, title, href) => {},
	scrollRestoration: ''
};

const scroll_history = {};

function extract_query(search) {
	const query = Object.create(null);
	if (search.length > 0) {
		search.slice(1).split('&').forEach(searchParam => {
			let [, key, value = ''] = /([^=]*)(?:=(.*))?/.exec(decodeURIComponent(searchParam.replace(/\+/g, ' ')));
			if (typeof query[key] === 'string') query[key] = [query[key]];
			if (typeof query[key] === 'object') (query[key] ).push(value);
			else query[key] = value;
		});
	}
	return query;
}

function select_target(url) {
	if (url.origin !== location.origin) return null;
	if (!url.pathname.startsWith(initial_data.baseUrl)) return null;

	let path = url.pathname.slice(initial_data.baseUrl.length);

	if (path === '') {
		path = '/';
	}

	// avoid accidental clashes between server routes and page routes
	if (ignore.some(pattern => pattern.test(path))) return;

	for (let i = 0; i < routes.length; i += 1) {
		const route = routes[i];

		const match = route.pattern.exec(path);

		if (match) {
			const query = extract_query(url.search);
			const part = route.parts[route.parts.length - 1];
			const params = part.params ? part.params(match) : {};

			const page = { host: location.host, path, query, params };

			return { href: url.href, route, match, page };
		}
	}
}

function scroll_state() {
	return {
		x: pageXOffset,
		y: pageYOffset
	};
}

async function navigate(target, id, noscroll, hash) {
	if (id) {
		// popstate or initial navigation
		cid = id;
	} else {
		const current_scroll = scroll_state();

		// clicked on a link. preserve scroll state
		scroll_history[cid] = current_scroll;

		id = cid = ++uid;
		scroll_history[cid] = noscroll ? current_scroll : { x: 0, y: 0 };
	}

	cid = id;

	if (root_component) stores.preloading.set(true);

	const loaded = prefetching && prefetching.href === target.href ?
		prefetching.promise :
		hydrate_target(target);

	prefetching = null;

	const token = current_token = {};
	const { redirect, props, branch } = await loaded;
	if (token !== current_token) return; // a secondary navigation happened while we were loading

	await render(redirect, branch, props, target.page);
	if (document.activeElement) document.activeElement.blur();

	if (!noscroll) {
		let scroll = scroll_history[id];

		if (hash) {
			// scroll is an element id (from a hash), we need to compute y.
			const deep_linked = document.getElementById(hash.slice(1));

			if (deep_linked) {
				scroll = {
					x: 0,
					y: deep_linked.getBoundingClientRect().top
				};
			}
		}

		scroll_history[cid] = scroll;
		if (scroll) scrollTo(scroll.x, scroll.y);
	}
}

async function render(redirect, branch, props, page) {
	if (redirect) return goto(redirect.location, { replaceState: true });

	stores.page.set(page);
	stores.preloading.set(false);

	if (root_component) {
		root_component.$set(props);
	} else {
		props.stores = {
			page: { subscribe: stores.page.subscribe },
			preloading: { subscribe: stores.preloading.subscribe },
			session: stores.session
		};
		props.level0 = {
			props: await root_preloaded
		};

		// first load — remove SSR'd <head> contents
		const start = document.querySelector('#sapper-head-start');
		const end = document.querySelector('#sapper-head-end');

		if (start && end) {
			while (start.nextSibling !== end) detach(start.nextSibling);
			detach(start);
			detach(end);
		}

		root_component = new App({
			target,
			props,
			hydrate: true
		});
	}

	current_branch = branch;
	current_query = JSON.stringify(page.query);
	ready = true;
	session_dirty = false;
}

function part_changed(i, segment, match, stringified_query) {
	// TODO only check query string changes for preload functions
	// that do in fact depend on it (using static analysis or
	// runtime instrumentation)
	if (stringified_query !== current_query) return true;

	const previous = current_branch[i];

	if (!previous) return false;
	if (segment !== previous.segment) return true;
	if (previous.match) {
		if (JSON.stringify(previous.match.slice(1, i + 2)) !== JSON.stringify(match.slice(1, i + 2))) {
			return true;
		}
	}
}

async function hydrate_target(target)



 {
	const { route, page } = target;
	const segments = page.path.split('/').filter(Boolean);

	let redirect = null;

	const props = { error: null, status: 200, segments: [segments[0]] };

	const preload_context = {
		fetch: (url, opts) => fetch(url, opts),
		redirect: (statusCode, location) => {
			if (redirect && (redirect.statusCode !== statusCode || redirect.location !== location)) {
				throw new Error(`Conflicting redirects`);
			}
			redirect = { statusCode, location };
		},
		error: (status, error) => {
			props.error = typeof error === 'string' ? new Error(error) : error;
			props.status = status;
		}
	};

	if (!root_preloaded) {
		root_preloaded = initial_data.preloaded[0] || preload.call(preload_context, {
			host: page.host,
			path: page.path,
			query: page.query,
			params: {}
		}, $session);
	}

	let branch;
	let l = 1;

	try {
		const stringified_query = JSON.stringify(page.query);
		const match = route.pattern.exec(page.path);

		let segment_dirty = false;

		branch = await Promise.all(route.parts.map(async (part, i) => {
			const segment = segments[i];

			if (part_changed(i, segment, match, stringified_query)) segment_dirty = true;

			props.segments[l] = segments[i + 1]; // TODO make this less confusing
			if (!part) return { segment };

			const j = l++;

			if (!session_dirty && !segment_dirty && current_branch[i] && current_branch[i].part === part.i) {
				return current_branch[i];
			}

			segment_dirty = false;

			const { default: component, preload } = await load_component(components[part.i]);

			let preloaded;
			if (ready || !initial_data.preloaded[i + 1]) {
				preloaded = preload
					? await preload.call(preload_context, {
						host: page.host,
						path: page.path,
						query: page.query,
						params: part.params ? part.params(target.match) : {}
					}, $session)
					: {};
			} else {
				preloaded = initial_data.preloaded[i + 1];
			}

			return (props[`level${j}`] = { component, props: preloaded, segment, match, part: part.i });
		}));
	} catch (error) {
		props.error = error;
		props.status = 500;
		branch = [];
	}

	return { redirect, props, branch };
}

function load_css(chunk) {
	const href = `client/${chunk}`;
	if (document.querySelector(`link[href="${href}"]`)) return;

	return new Promise((fulfil, reject) => {
		const link = document.createElement('link');
		link.rel = 'stylesheet';
		link.href = href;

		link.onload = () => fulfil();
		link.onerror = reject;

		document.head.appendChild(link);
	});
}

function load_component(component)


 {
	// TODO this is temporary — once placeholders are
	// always rewritten, scratch the ternary
	const promises = (typeof component.css === 'string' ? [] : component.css.map(load_css));
	promises.unshift(component.js());
	return Promise.all(promises).then(values => values[0]);
}

function detach(node) {
	node.parentNode.removeChild(node);
}

const stores$1 = () => index.getContext(CONTEXT_KEY);

exports.App = App;
exports.error = Error$1;
exports.goto = goto;
exports.root = Layout;
exports.stores$1 = stores$1;
exports.writable = writable;
